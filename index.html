<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR Zombie Shooter: Cyberpunk Edition (WebXR 6DoF)</title>
    
    <!-- Libraries -->
    <!-- A-Frame 1.4.0 supports WebXR nicely -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <style>
        /* RESET & BASE */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #000; 
            user-select: none; -webkit-user-select: none;
            touch-action: manipulation;
        }
        
        /* Video Element untuk MediaPipe (Hidden/Background processing) */
        #input-video {
            position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0;
            z-index: -10;
        }

        /* UI LAYER */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 999;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Damage Overlay */
        #damage-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.9) 100%);
            opacity: 0; transition: opacity 0.1s; pointer-events: none; z-index: 900;
            mix-blend-mode: overlay;
        }

        /* HUD PANELS */
        .hud-top { 
            display: flex; justify-content: space-between; padding: 20px; 
            padding-top: max(20px, env(safe-area-inset-top));
        }
        
        .hud-panel {
            background: rgba(0, 15, 30, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.6);
            padding: 10px 25px;
            transform: skewX(-15deg);
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .hud-content { transform: skewX(15deg); text-align: center; }

        .hud-label { 
            font-family: 'Share Tech Mono', monospace; font-size: 10px; 
            color: #00ffff; letter-spacing: 2px; text-shadow: 0 0 5px #00ffff;
        }
        
        .hud-value { 
            font-family: 'Orbitron', sans-serif; font-size: 28px; 
            color: #fff; font-weight: 900; text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .panel-kills { border-left: 5px solid #00ffff; }
        .panel-wave { border-right: 5px solid #ffaa00; }
        .panel-wave .hud-label { color: #ffaa00; text-shadow: 0 0 5px #ffaa00; }
        .panel-wave .hud-value { color: #ffaa00; }

        /* BOTTOM HUD */
        .hud-bottom {
            display: flex; align-items: flex-end; justify-content: space-between; 
            padding: 20px; padding-bottom: max(30px, env(safe-area-inset-bottom));
        }

        /* HEALTH BAR */
        .health-container { width: 200px; transform: skewX(-15deg); }
        .health-bar-bg { 
            width: 100%; height: 15px; background: rgba(50, 0, 0, 0.8); 
            border: 2px solid #ff0000; box-shadow: 0 0 10px #ff0000;
        }
        .health-bar-fill { 
            width: 100%; height: 100%; background: #ff0000; 
            box-shadow: inset 0 0 10px #500; transition: width 0.2s;
        }
        .health-label { 
            color: #fff; font-family: 'Orbitron'; font-size: 12px; 
            margin-bottom: 5px; text-shadow: 0 0 5px #ff0000; transform: skewX(15deg);
        }

        /* AMMO */
        .panel-ammo { 
            border-right: 5px solid #ff0000; background: rgba(20, 0, 0, 0.85); 
            border-color: rgba(255, 0, 0, 0.6);
        }
        .panel-ammo .hud-label { color: #ff5555; text-shadow: 0 0 5px #ff0000; }
        .panel-ammo .hud-value { color: #ff0000; font-size: 36px; }

        /* CURSOR & HAND STATUS */
        .crosshair {
            position: absolute; width: 60px; height: 60px; 
            border: 2px solid #0f0; border-radius: 50%;
            transform: translate(-50%, -50%); opacity: 0; 
            box-shadow: 0 0 15px #0f0, inset 0 0 10px #0f0; pointer-events: none;
            display: flex; align-items: center; justify-content: center;
            transition: opacity 0.2s;
        }
        .crosshair.active { opacity: 1; }
        .crosshair::after { content: ''; width: 4px; height: 4px; background: #fff; border-radius: 50%; }
        /* Target lines for crosshair */
        .crosshair::before {
            content: ''; position: absolute; width: 100%; height: 100%;
            background: linear-gradient(to bottom, transparent 48%, #0f0 48%, #0f0 52%, transparent 52%),
                        linear-gradient(to right, transparent 48%, #0f0 48%, #0f0 52%, transparent 52%);
            opacity: 0.5;
        }

        #hand-status {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Share Tech Mono'; color: rgba(0, 255, 255, 0.8); font-size: 14px;
            text-align: center; text-shadow: 0 0 5px #00ffff; pointer-events: none;
            background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 4px;
            border: 1px solid #00ffff;
        }

        /* RADAR */
        .radar-box {
            position: absolute; bottom: 100px; left: 20px;
            width: 100px; height: 100px; border: 2px solid #0f0; border-radius: 50%;
            background: rgba(0, 20, 0, 0.8); overflow: hidden;
            box-shadow: 0 0 10px #0f0; pointer-events: auto;
        }
        .radar-center { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: #fff; transform: translate(-50%, -50%); border-radius: 50%; }
        .radar-blip { position: absolute; width: 6px; height: 6px; background: red; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 4px #fff; }

        /* BUTTONS */
        #fire-btn {
            position: absolute; bottom: 120px; right: 30px;
            width: 100px; height: 100px; border-radius: 50%;
            background: rgba(255, 0, 0, 0.2); border: 4px solid #ff0000;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Orbitron'; color: white; font-weight: bold; font-size: 18px;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.6); pointer-events: auto; z-index: 1000;
            backdrop-filter: blur(2px);
            transition: transform 0.1s, background 0.1s;
        }
        #fire-btn:active { background: rgba(255, 0, 0, 0.8); transform: scale(0.9); }

        /* SCREENS */
        .fullscreen-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; pointer-events: auto;
        }
        .btn-start {
            background: linear-gradient(45deg, #cc0000, #990000);
            color: #fff; padding: 15px 50px; border: none;
            font-family: 'Orbitron'; font-weight: 900; font-size: 24px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            letter-spacing: 2px; cursor: pointer; margin-top: 30px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            transition: transform 0.2s;
        }
        .btn-start:hover { transform: scale(1.05); }
        
        #xr-warning {
            color: orange; font-family: sans-serif; font-size: 12px; margin-top: 10px; display: none;
        }
    </style>
</head>

<body>
    <!-- Hidden Video for MediaPipe -->
    <video id="input-video" autoplay playsinline></video>

    <div id="damage-flash"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-panel panel-kills">
                <div class="hud-content">
                    <div class="hud-label">KILLS</div>
                    <div class="hud-value" id="score">0</div>
                </div>
            </div>
            <div class="hud-panel panel-wave">
                <div class="hud-content">
                    <div class="hud-label">WAVE</div>
                    <div class="hud-value" id="wave">1</div>
                </div>
            </div>
        </div>

        <!-- Hand Tracking Cursor -->
        <div class="crosshair" id="finger-cursor"></div>
        <div id="hand-status">SYSTEM BOOTING...<br>Izinkan Kamera & Tunggu</div>
        
        <div class="radar-box" id="radar"><div class="radar-center"></div></div>
        <div id="fire-btn">FIRE</div>

        <div class="hud-bottom">
            <div class="health-container">
                <div class="health-label">HP INTEGRITY</div>
                <div class="health-bar-bg"><div class="health-bar-fill" id="hp-bar"></div></div>
            </div>
            <div class="hud-panel panel-ammo">
                <div class="hud-content">
                    <div class="hud-label">AMMO</div>
                    <div class="hud-value" id="ammo">30</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="fullscreen-overlay">
        <h1 style="font-family:'Orbitron'; color:red; font-size: 40px; text-shadow: 0 0 20px red;">ZOMBIE PROTOCOL</h1>
        <p style="color:#aaa; font-family:'Share Tech Mono'; margin-bottom: 10px;">
            [ WEBXR 6DoF ENABLED ]
        </p>
        <p style="color:#0ff; font-family:'Share Tech Mono'; font-size: 14px; max-width: 300px; line-height: 1.5;">
            1. Game ini mendukung <strong>PERGERAKAN FISIK</strong>. Mundur untuk menghindar!<br>
            2. Angkat jari untuk membidik.<br>
            3. Tekan tombol FIRE untuk menembak.
        </p>
        <div id="xr-warning">Note: Hand Tracking mungkin melambat saat mode AR aktif.</div>
        <button class="btn-start" onclick="startGame()">ENTER AR WORLD</button>
    </div>

    <div id="game-over-screen" class="fullscreen-overlay" style="display: none;">
        <h1 style="font-family:'Orbitron'; color:red; font-size: 40px;">FATAL ERROR</h1>
        <p style="color:white; margin-bottom: 20px;">OPERATOR KILLED</p>
        <button class="btn-start" onclick="location.reload()">REBOOT SYSTEM</button>
    </div>

    <!-- A-Frame Scene Configured for WebXR (No GPS) -->
    <a-scene 
        webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: #ui-layer"
        renderer="antialias: true; colorManagement: true; logarithmicDepthBuffer: true;"
        loading-screen="enabled: false">

        <!-- Assets -->
        <a-assets>
            <a-asset-item id="titan-model" src="https://raw.githack.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMan/glTF-Binary/CesiumMan.glb"></a-asset-item>
        </a-assets>

        <!-- Lighting -->
        <a-light type="ambient" color="#fff" intensity="0.6"></a-light>
        <a-light type="directional" color="#0ff" intensity="1.2" position="-1 2 0"></a-light>

        <!-- Camera Rig for WebXR -->
        <!-- Posisi 0 0 0 adalah titik awal dunia saat game dimulai -->
        <a-entity id="rig" position="0 0 0">
            <a-camera id="player-camera" position="0 1.6 0" look-controls="enabled: true">
                <!-- PISTOL 3D PROCEDURAL -->
                <!-- Menempel pada kamera (Head Locked) atau Tangan -->
                <a-entity id="player-gun" position="0.2 -0.3 -0.5" rotation="0 0 0" scale="1 1 1" visible="false">
                    <a-box color="#111" width="0.08" height="0.12" depth="0.3" position="0 0 0"></a-box>
                    <a-cylinder color="#333" radius="0.03" height="0.4" rotation="90 0 0" position="0 0.05 -0.2"></a-cylinder>
                    <a-box color="#0ff" width="0.09" height="0.02" depth="0.3" position="0 0.07 0" material="emissive: #0ff; emissiveIntensity: 2"></a-box>
                    <a-box color="#222" width="0.06" height="0.15" depth="0.08" position="0 -0.1 0.1" rotation="-20 0 0"></a-box>
                    <a-cylinder color="#0f0" radius="0.001" height="100" rotation="90 0 0" position="0 0.05 -50" opacity="0.4"></a-cylinder>
                    <a-sphere id="muzzle-flash" color="#fff" radius="0.1" position="0 0.05 -0.5" visible="false" material="emissive: #fff; emissiveIntensity: 10"></a-sphere>
                </a-entity>
            </a-camera>
        </a-entity>
        
        <!-- Floor (Invisible for physics/shadows if needed) -->
        <a-plane rotation="-90 0 0" width="100" height="100" color="#000" opacity="0"></a-plane>

    </a-scene>

    <script>
        // CONFIG
        const CONFIG = {
            spawnDistMin: 5, spawnDistMax: 12, // Jarak spawn lebih dekat (meter)
            modelScale: 10,  // Skala Titan (Cukup besar tapi proporsional)
            yOffset: 0,      // 0 = LANTAI dalam WebXR (Penting!)
            radarScale: 4.0, // Skala radar disesuaikan untuk jarak dekat
            damageDistance: 2.5, // Jarak serang zombie
            startAmmo: 50,
            lerpFactor: 0.5 
        };

        let gameState = { running: false, score: 0, wave: 1, zombies: [], hp: 100, ammo: CONFIG.startAmmo };
        let handData = { rawX: 0.5, rawY: 0.5, x: 0.5, y: 0.5, detected: false };
        let shootableObjects = []; 

        // --- CAMERA INIT (MANUAL FOR MEDIAPIPE) ---
        async function initCamera() {
            const video = document.getElementById('input-video');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                video.srcObject = stream;
                return new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve(video);
                    };
                });
            } catch (err) {
                console.error("Camera Init Error:", err);
                document.getElementById('hand-status').innerHTML = "CAMERA ERROR<br>Refused or Busy";
                // Lanjut game tanpa hands jika error (WebXR only mode)
                return null;
            }
        }

        // --- UTILS: LERP ---
        function lerp(start, end, amt) { return (1 - amt) * start + amt * end; }

        // --- HAND TRACKING SETUP ---
        let hands;
        function setupMediaPipe() {
            hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
            });
            hands.onResults(onHandResults);
        }

        function onHandResults(results) {
            const cursor = document.getElementById('finger-cursor');
            const status = document.getElementById('hand-status');
            const gun = document.getElementById('player-gun');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handData.detected = true;
                status.style.display = 'none';
                cursor.classList.add('active');
                if(gun) gun.setAttribute('visible', 'true');

                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8]; 
                
                // Normalisasi Koordinat
                handData.rawX = 1.0 - indexTip.x; 
                handData.rawY = indexTip.y;
            } else {
                handData.detected = false;
                cursor.classList.remove('active');
                status.style.display = 'block';
                status.innerHTML = "LOST TRACKING<br>Angkat Tangan";
            }
        }

        // --- GAME LOOP & SMOOTHING ---
        function gameLoop() {
            if (!gameState.running) return;

            // 1. Smooth Hand Movement
            if (handData.detected) {
                handData.x = lerp(handData.x, handData.rawX, CONFIG.lerpFactor);
                handData.y = lerp(handData.y, handData.rawY, CONFIG.lerpFactor);
            }

            // 2. Update UI
            const cursor = document.getElementById('finger-cursor');
            cursor.style.left = `${handData.x * 100}%`;
            cursor.style.top = `${handData.y * 100}%`;

            // 3. Update Gun Position (Local Space to Camera)
            const gun = document.getElementById('player-gun');
            if (gun) {
                const targetX = (handData.x - 0.5) * 1.5; 
                const targetY = -(handData.y - 0.5) * 1.2; 
                
                gun.object3D.position.x = lerp(gun.object3D.position.x, targetX + 0.2, 0.1);
                gun.object3D.position.y = lerp(gun.object3D.position.y, targetY - 0.25, 0.1);
                
                // Tilt Effect
                gun.object3D.rotation.y = (-targetX * 0.5) + 0.1; 
                gun.object3D.rotation.x = targetY * 0.4;
                gun.object3D.rotation.z = 0.1; 
            }

            requestAnimationFrame(gameLoop);
        }

        // --- TITAN ZOMBIE AI ---
        AFRAME.registerComponent('titan-ai', {
            init: function() { 
                // Set posisi Y ke 0 (Lantai) saat init
                this.el.object3D.position.y = CONFIG.yOffset; 
            },
            tick: function() {
                if (!gameState.running || this.el.dataset.dead === "true") return;
                
                const zPos = this.el.object3D.position;
                const camEl = document.getElementById('player-camera');
                if(!camEl) return;

                // Ambil World Position kamera (karena kamera bergerak di WebXR)
                const camPos = new THREE.Vector3();
                camEl.object3D.getWorldPosition(camPos);
                
                // Hitung jarak
                const dx = zPos.x - camPos.x;
                const dz = zPos.z - camPos.z;
                const dist = Math.sqrt(dx*dx + dz*dz);

                // Chase Logic (Hanya sumbu X dan Z, Y tetap di lantai)
                if (dist > 1.5) {
                    this.el.object3D.lookAt(camPos.x, CONFIG.yOffset, camPos.z);
                    const dir = new THREE.Vector3(dx, 0, dz).normalize().negate(); 
                    this.el.object3D.position.addScaledVector(dir, 0.03); // Speed (Meter per frame)
                }

                // Attack Logic
                if (dist <= CONFIG.damageDistance) {
                    if (!this.lastHit || Date.now() - this.lastHit > 1000) {
                        takeDamage(10);
                        this.lastHit = Date.now();
                        // Shake effect
                        const ui = document.getElementById('ui-layer');
                        ui.style.transform = "translate(5px, 5px)";
                        setTimeout(() => ui.style.transform = "none", 50);
                    }
                }
            }
        });

        // --- CORE FUNCTIONS ---
        async function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameState.running = true;
            
            // 1. Init Manual Camera untuk MediaPipe
            const videoEl = await initCamera();
            
            // 2. Setup MediaPipe
            setupMediaPipe();
            
            // 3. Process Video Loop
            if(videoEl) {
                async function processVideo() {
                    if (!gameState.running) return;
                    try { await hands.send({image: videoEl}); } catch (e) {}
                    requestAnimationFrame(processVideo);
                }
                processVideo();
            }

            gameLoop();
            spawnWave();
            setInterval(updateRadar, 150);

            // Inputs
            const fireBtn = document.getElementById('fire-btn');
            const handler = (e) => { e.preventDefault(); shoot(); };
            fireBtn.addEventListener('touchstart', handler, {passive: false});
            fireBtn.addEventListener('mousedown', handler);
        }

        function spawnWave() { for(let i=0; i<3; i++) setTimeout(spawnTitan, i * 1000); }

        function spawnTitan() {
            const scene = document.querySelector('a-scene');
            const zombie = document.createElement('a-entity');
            zombie.setAttribute('titan-ai', '');
            zombie.classList.add('zombie');

            // Spawn di sekitar titik 0,0,0 (Start Position)
            // Bukan di kamera, agar saat player jalan, zombie tetap di tempat (World Locking)
            const angle = Math.random() * Math.PI * 2;
            const dist = CONFIG.spawnDistMin + Math.random() * (CONFIG.spawnDistMax - CONFIG.spawnDistMin);
            
            zombie.setAttribute('position', {
                x: Math.sin(angle) * dist,
                y: CONFIG.yOffset, // LANTAI
                z: Math.cos(angle) * dist
            });

            // Model
            const model = document.createElement('a-entity');
            model.setAttribute('gltf-model', '#titan-model');
            model.setAttribute('scale', `${CONFIG.modelScale} ${CONFIG.modelScale} ${CONFIG.modelScale}`);
            model.setAttribute('animation-mixer', 'clip: *; loop: repeat; timeScale: 1.5');
            zombie.appendChild(model);

            // Hitbox
            const geometry = new THREE.BoxGeometry(0.5 * CONFIG.modelScale, 2 * CONFIG.modelScale, 0.5 * CONFIG.modelScale);
            const material = new THREE.MeshBasicMaterial({ visible: false }); 
            const hitboxMesh = new THREE.Mesh(geometry, material);
            hitboxMesh.position.set(0, 1 * CONFIG.modelScale, 0);
            
            hitboxMesh.userData = { parentEntity: zombie };
            zombie.object3D.add(hitboxMesh);
            shootableObjects.push(hitboxMesh);

            scene.appendChild(zombie);
            gameState.zombies.push(zombie);
        }

        function shoot() {
            if (!gameState.running || gameState.ammo <= 0) return;
            gameState.ammo--; updateHUD();

            // FX
            const gun = document.getElementById('player-gun');
            const flash = document.getElementById('muzzle-flash');
            if(gun) {
                gun.object3D.position.z += 0.2;
                flash.setAttribute('visible', 'true');
                setTimeout(() => {
                    gun.object3D.position.z -= 0.2;
                    flash.setAttribute('visible', 'false');
                }, 80);
            }

            // Raycasting
            let hitFound = false;
            const raycaster = new THREE.Raycaster();
            const camEl = document.getElementById('player-camera');
            const threeCamera = camEl.getObject3D('camera');

            const x = (handData.x * 2) - 1;
            const y = -(handData.y * 2) + 1;

            raycaster.setFromCamera(new THREE.Vector2(x, y), threeCamera);
            const intersects = raycaster.intersectObjects(shootableObjects);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                if (hitObject.userData?.parentEntity?.dataset.dead !== "true") {
                    killZombie(hitObject.userData.parentEntity, hitObject);
                    hitFound = true;
                }
            }

            // Aim Assist (Screen Space)
            if (!hitFound) {
                gameState.zombies.forEach(zombie => {
                    if (hitFound || zombie.dataset.dead === "true") return;
                    
                    const pos = new THREE.Vector3();
                    zombie.object3D.getWorldPosition(pos);
                    pos.project(threeCamera);

                    const dist = Math.sqrt((pos.x - x)**2 + (pos.y - y)**2);
                    if (dist < 0.25 && pos.z < 1) {
                        killZombie(zombie, null);
                        hitFound = true;
                    }
                });
            }
        }

        function killZombie(el, hitboxMesh) {
            el.dataset.dead = "true";
            if (hitboxMesh) {
                const index = shootableObjects.indexOf(hitboxMesh);
                if (index > -1) shootableObjects.splice(index, 1);
            }
            el.setAttribute('animation', 'property: rotation; to: -90 0 0; dur: 800; easing: easeOutQuad');
            gameState.score++;
            updateHUD();
            setTimeout(() => {
                if (el.parentNode) el.parentNode.removeChild(el);
                gameState.zombies = gameState.zombies.filter(z => z !== el);
                if (gameState.zombies.length < 2) spawnWave();
            }, 1000);
        }

        function takeDamage(amt) {
            gameState.hp -= amt;
            updateHUD();
            const flash = document.getElementById('damage-flash');
            flash.style.opacity = 1; setTimeout(() => flash.style.opacity = 0, 200);
            if (gameState.hp <= 0) {
                gameState.running = false;
                document.getElementById('game-over-screen').style.display = 'flex';
            }
        }

        function updateHUD() {
            document.getElementById('score').innerText = gameState.score;
            document.getElementById('ammo').innerText = gameState.ammo;
            document.getElementById('hp-bar').style.width = Math.max(0, gameState.hp) + '%';
        }

        function updateRadar() {
            const radar = document.getElementById('radar');
            radar.innerHTML = '<div class="radar-center"></div>';
            
            const camEl = document.getElementById('player-camera');
            if (!camEl) return;

            const cam = camEl.object3D;
            const camPos = new THREE.Vector3();
            cam.getWorldPosition(camPos);
            
            const vec = new THREE.Vector3();
            cam.getWorldDirection(vec);
            const angle = Math.atan2(vec.x, vec.z);

            gameState.zombies.forEach(z => {
                if (z.dataset.dead === "true") return;
                const zPos = z.object3D.position;
                
                const dx = zPos.x - camPos.x;
                const dz = zPos.z - camPos.z;
                
                const rx = dx * Math.cos(angle) - dz * Math.sin(angle);
                const rz = dx * Math.sin(angle) + dz * Math.cos(angle);
                
                const px = 50 + (rx * CONFIG.radarScale * 2.5); // Adjusted scale
                const py = 50 - (rz * CONFIG.radarScale * 2.5);
                
                if (Math.sqrt((px-50)**2 + (py-50)**2) < 45) {
                    const blip = document.createElement('div');
                    blip.className = 'radar-blip';
                    blip.style.left = px + 'px'; 
                    blip.style.top = py + 'px';
                    radar.appendChild(blip);
                }
            });
        }
    </script>
</body>
</html>
