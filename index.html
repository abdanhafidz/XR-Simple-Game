<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR Zombie Shooter: Cyberpunk Edition (Height Fixed)</title>
    
    <!-- Libraries -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src='https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js'></script>
    <script src="https://raw.githack.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <style>
        /* RESET & BASE */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #000; 
            user-select: none; -webkit-user-select: none;
            touch-action: manipulation; /* Mencegah zoom/scroll browser */
        }
        
        #arjs-video, video {
            width: 100% !important; height: 100% !important;
            top: 0 !important; left: 0 !important;
            z-index: -2 !important; object-fit: cover !important;
            margin: 0 !important; position: absolute !important;
        }

        /* UI LAYER */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 999;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Damage Overlay */
        #damage-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.9) 100%);
            opacity: 0; transition: opacity 0.1s; pointer-events: none; z-index: 900;
            mix-blend-mode: overlay;
        }

        /* HUD PANELS */
        .hud-top { 
            display: flex; justify-content: space-between; padding: 20px; 
            padding-top: max(20px, env(safe-area-inset-top));
        }
        
        .hud-panel {
            background: rgba(0, 15, 30, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.6);
            padding: 10px 25px;
            transform: skewX(-15deg);
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .hud-content { transform: skewX(15deg); text-align: center; }

        .hud-label { 
            font-family: 'Share Tech Mono', monospace; font-size: 10px; 
            color: #00ffff; letter-spacing: 2px; text-shadow: 0 0 5px #00ffff;
        }
        
        .hud-value { 
            font-family: 'Orbitron', sans-serif; font-size: 28px; 
            color: #fff; font-weight: 900; text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .panel-kills { border-left: 5px solid #00ffff; }
        .panel-wave { border-right: 5px solid #ffaa00; }
        .panel-wave .hud-label { color: #ffaa00; text-shadow: 0 0 5px #ffaa00; }
        .panel-wave .hud-value { color: #ffaa00; }

        /* BOTTOM HUD */
        .hud-bottom {
            display: flex; align-items: flex-end; justify-content: space-between; 
            padding: 20px; padding-bottom: max(30px, env(safe-area-inset-bottom));
        }

        /* HEALTH BAR */
        .health-container { width: 200px; transform: skewX(-15deg); }
        .health-bar-bg { 
            width: 100%; height: 15px; background: rgba(50, 0, 0, 0.8); 
            border: 2px solid #ff0000; box-shadow: 0 0 10px #ff0000;
        }
        .health-bar-fill { 
            width: 100%; height: 100%; background: #ff0000; 
            box-shadow: inset 0 0 10px #500; transition: width 0.2s;
        }
        .health-label { 
            color: #fff; font-family: 'Orbitron'; font-size: 12px; 
            margin-bottom: 5px; text-shadow: 0 0 5px #ff0000; transform: skewX(15deg);
        }

        /* AMMO */
        .panel-ammo { 
            border-right: 5px solid #ff0000; background: rgba(20, 0, 0, 0.85); 
            border-color: rgba(255, 0, 0, 0.6);
        }
        .panel-ammo .hud-label { color: #ff5555; text-shadow: 0 0 5px #ff0000; }
        .panel-ammo .hud-value { color: #ff0000; font-size: 36px; }

        /* CURSOR & HAND STATUS */
        .crosshair {
            position: absolute; width: 60px; height: 60px; 
            border: 2px solid #0f0; border-radius: 50%;
            transform: translate(-50%, -50%); opacity: 0; 
            box-shadow: 0 0 15px #0f0, inset 0 0 10px #0f0; pointer-events: none;
            display: flex; align-items: center; justify-content: center;
            transition: opacity 0.2s;
        }
        .crosshair.active { opacity: 1; }
        .crosshair::after { content: ''; width: 4px; height: 4px; background: #fff; border-radius: 50%; }
        /* Target lines for crosshair */
        .crosshair::before {
            content: ''; position: absolute; width: 100%; height: 100%;
            background: linear-gradient(to bottom, transparent 48%, #0f0 48%, #0f0 52%, transparent 52%),
                        linear-gradient(to right, transparent 48%, #0f0 48%, #0f0 52%, transparent 52%);
            opacity: 0.5;
        }

        #hand-status {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Share Tech Mono'; color: rgba(0, 255, 255, 0.8); font-size: 14px;
            text-align: center; text-shadow: 0 0 5px #00ffff; pointer-events: none;
            background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 4px;
            border: 1px solid #00ffff;
        }

        /* RADAR */
        .radar-box {
            position: absolute; bottom: 100px; left: 20px;
            width: 100px; height: 100px; border: 2px solid #0f0; border-radius: 50%;
            background: rgba(0, 20, 0, 0.8); overflow: hidden;
            box-shadow: 0 0 10px #0f0; pointer-events: auto;
        }
        .radar-center { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: #fff; transform: translate(-50%, -50%); border-radius: 50%; }
        .radar-blip { position: absolute; width: 6px; height: 6px; background: red; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 4px #fff; }

        /* BUTTONS */
        #fire-btn {
            position: absolute; bottom: 120px; right: 30px;
            width: 100px; height: 100px; border-radius: 50%;
            background: rgba(255, 0, 0, 0.2); border: 4px solid #ff0000;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Orbitron'; color: white; font-weight: bold; font-size: 18px;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.6); pointer-events: auto; z-index: 1000;
            backdrop-filter: blur(2px);
            transition: transform 0.1s, background 0.1s;
        }
        #fire-btn:active { background: rgba(255, 0, 0, 0.8); transform: scale(0.9); }

        /* SCREENS */
        .fullscreen-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; pointer-events: auto;
        }
        .btn-start {
            background: linear-gradient(45deg, #cc0000, #990000);
            color: #fff; padding: 15px 50px; border: none;
            font-family: 'Orbitron'; font-weight: 900; font-size: 24px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            letter-spacing: 2px; cursor: pointer; margin-top: 30px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            transition: transform 0.2s;
        }
        .btn-start:hover { transform: scale(1.05); }
    </style>
</head>

<body>
    <div id="damage-flash"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-panel panel-kills">
                <div class="hud-content">
                    <div class="hud-label">KILLS</div>
                    <div class="hud-value" id="score">0</div>
                </div>
            </div>
            <div class="hud-panel panel-wave">
                <div class="hud-content">
                    <div class="hud-label">WAVE</div>
                    <div class="hud-value" id="wave">1</div>
                </div>
            </div>
        </div>

        <!-- Hand Tracking Cursor -->
        <div class="crosshair" id="finger-cursor"></div>
        <div id="hand-status">SYSTEM BOOTING...<br>Izinkan Kamera & Tunggu</div>
        
        <div class="radar-box" id="radar"><div class="radar-center"></div></div>
        <div id="fire-btn">FIRE</div>

        <div class="hud-bottom">
            <div class="health-container">
                <div class="health-label">HP INTEGRITY</div>
                <div class="health-bar-bg"><div class="health-bar-fill" id="hp-bar"></div></div>
            </div>
            <div class="hud-panel panel-ammo">
                <div class="hud-content">
                    <div class="hud-label">AMMO</div>
                    <div class="hud-value" id="ammo">30</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="fullscreen-overlay">
        <h1 style="font-family:'Orbitron'; color:red; font-size: 40px; text-shadow: 0 0 20px red;">ZOMBIE PROTOCOL</h1>
        <p style="color:#aaa; font-family:'Share Tech Mono'; margin-bottom: 10px;">
            [ AIM ASSIST ENABLED ]
        </p>
        <p style="color:#0ff; font-family:'Share Tech Mono'; font-size: 14px; max-width: 300px; line-height: 1.5;">
            1. Angkat jari telunjuk untuk membidik.<br>
            2. Tekan tombol FIRE di layar untuk menembak.<br>
            3. Putar badan fisik anda untuk mencari musuh (AR).
        </p>
        <button class="btn-start" onclick="startGame()">INITIATE</button>
    </div>

    <div id="game-over-screen" class="fullscreen-overlay" style="display: none;">
        <h1 style="font-family:'Orbitron'; color:red; font-size: 40px;">FATAL ERROR</h1>
        <p style="color:white; margin-bottom: 20px;">SIGNAL LOST</p>
        <button class="btn-start" onclick="location.reload()">REBOOT SYSTEM</button>
    </div>

    <a-scene 
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true; precision: high; antialias: true;"
        arjs='sourceType: webcam; videoTexture: true; debugUIEnabled: false;'
        loading-screen="enabled: false">

        <!-- Assets: Titan Zombie -->
        <a-assets>
            <a-asset-item id="titan-model" src="https://raw.githack.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMan/glTF-Binary/CesiumMan.glb"></a-asset-item>
        </a-assets>

        <a-light type="ambient" color="#fff" intensity="1.0"></a-light>
        <a-light type="directional" color="#0ff" intensity="1.5" position="-1 1 0"></a-light>
        <a-light type="directional" color="#f00" intensity="0.5" position="1 1 0"></a-light>

        <a-camera gps-camera rotation-reader far="5000">
            <!-- PISTOL 3D PROCEDURAL (Neon Style) -->
            <a-entity id="player-gun" position="-0.2 -0.4 -1.5" rotation="0 0 0" scale="1.5 1.5 1.5" visible="false">
                <a-box color="#111" width="0.08" height="0.12" depth="0.3" position="0 0 0"></a-box>
                <a-cylinder color="#333" radius="0.03" height="0.4" rotation="90 0 0" position="0 0.05 -0.2"></a-cylinder>
                <a-box color="#0ff" width="0.09" height="0.02" depth="0.3" position="0 0.07 0" material="emissive: #0ff; emissiveIntensity: 2"></a-box>
                <a-box color="#222" width="0.06" height="0.15" depth="0.08" position="0 -0.1 0.1" rotation="-20 0 0"></a-box>
                <!-- Laser Sight -->
                <a-cylinder color="#0f0" radius="0.001" height="100" rotation="90 0 0" position="0 0.05 -50" opacity="0.4" material="emissive: #0f0; emissiveIntensity: 1"></a-cylinder>
                <!-- Muzzle Flash -->
                <a-sphere id="muzzle-flash" color="#fff" radius="0.1" position="0 0.05 -0.5" visible="false" material="emissive: #fff; emissiveIntensity: 10"></a-sphere>
            </a-entity>
        </a-camera>
    </a-scene>

    <script>
        // CONFIG
        const CONFIG = {
            spawnDistMin: 100, spawnDistMax: 200, 
            modelScale: 80, 
            yOffset: -120,
            // FIX: Radar scale dikecilkan (0.2) agar cover area 200m
            radarScale: 0.2, 
            damageDistance: 15.0,
            startAmmo: 30,
            lerpFactor: 0.5 
        };

        let gameState = { running: false, score: 0, wave: 1, zombies: [], hp: 100, ammo: CONFIG.startAmmo };
        let handData = { 
            rawX: 0.5, rawY: 0.5,
            x: 0.5, y: 0.5,
            detected: false 
        };
        
        let shootableObjects = []; 

        // --- UTILS: LERP ---
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        // --- HAND TRACKING SETUP ---
        let hands;
        let camera = null; 

        function setupMediaPipe() {
            hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onHandResults);
        }

        function onHandResults(results) {
            const cursor = document.getElementById('finger-cursor');
            const status = document.getElementById('hand-status');
            const gun = document.getElementById('player-gun');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handData.detected = true;
                status.style.display = 'none';
                cursor.classList.add('active');
                if(gun) gun.setAttribute('visible', 'true');

                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8]; 
                
                handData.rawX = 1.0 - indexTip.x; 
                handData.rawY = indexTip.y;

            } else {
                handData.detected = false;
                cursor.classList.remove('active');
                status.style.display = 'block';
                status.innerHTML = "LOST TRACKING<br>Angkat Tangan";
            }
        }

        // --- GAME LOOP & SMOOTHING ---
        function gameLoop() {
            if (!gameState.running) return;

            // 1. Smooth Hand Movement (Lerp)
            if (handData.detected) {
                handData.x = lerp(handData.x, handData.rawX, CONFIG.lerpFactor);
                handData.y = lerp(handData.y, handData.rawY, CONFIG.lerpFactor);
            }

            // 2. Update UI Position
            const cursor = document.getElementById('finger-cursor');
            cursor.style.left = `${handData.x * 100}%`;
            cursor.style.top = `${handData.y * 100}%`;

            // 3. Update 3D Gun Position
            const gun = document.getElementById('player-gun');
            if (gun) {
                const targetX = (handData.x - 0.5) * 1.5; 
                const targetY = -(handData.y - 0.5) * 1.2; 
                
                gun.object3D.position.x = lerp(gun.object3D.position.x, targetX - 0.1, 0.1);
                gun.object3D.position.y = lerp(gun.object3D.position.y, targetY - 0.25, 0.1);
                
                gun.object3D.rotation.y = (-targetX * 0.5) + 0.2; 
                gun.object3D.rotation.x = targetY * 0.4;
                gun.object3D.rotation.z = 0.15;
            }

            requestAnimationFrame(gameLoop);
        }

        // --- TITAN ZOMBIE AI ---
        AFRAME.registerComponent('titan-ai', {
            init: function() { this.el.object3D.position.y = CONFIG.yOffset; },
            tick: function() {
                if (!gameState.running || this.el.dataset.dead === "true") return;
                const zPos = this.el.object3D.position;
                
                const camEl = document.querySelector('[gps-camera]');
                if (!camEl || !camEl.object3D) return;
                
                const camPos = camEl.object3D.position;
                
                const dx = zPos.x - camPos.x;
                const dz = zPos.z - camPos.z;
                const dist = Math.sqrt(dx*dx + dz*dz);

                // Chase logic
                if (dist > 2) {
                    this.el.object3D.lookAt(camPos.x, zPos.y, camPos.z);
                    const dir = new THREE.Vector3(dx, 0, dz).normalize().negate(); 
                    this.el.object3D.position.addScaledVector(dir, 0.25);
                }

                // Damage logic
                if (dist <= CONFIG.damageDistance) {
                    if (!this.lastHit || Date.now() - this.lastHit > 1000) {
                        takeDamage(10);
                        this.lastHit = Date.now();
                        document.body.style.transform = "translate(5px, 5px)";
                        setTimeout(() => document.body.style.transform = "none", 50);
                    }
                }
            }
        });

        // --- CORE FUNCTIONS ---
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameState.running = true;
            setupMediaPipe();
            
            const checkVideoInterval = setInterval(() => {
                const videoElement = document.querySelector('video');
                if (videoElement && videoElement.readyState >= 2) {
                    clearInterval(checkVideoInterval);
                    processVideo(videoElement);
                    console.log("Video Stream Captured");
                }
            }, 500);

            gameLoop();
            spawnWave();
            setInterval(updateRadar, 150);

            const fireBtn = document.getElementById('fire-btn');
            fireBtn.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                shoot(); 
            }, {passive: false});
            fireBtn.addEventListener('mousedown', (e) => { 
                e.preventDefault(); 
                shoot(); 
            });
        }

        async function processVideo(videoElement) {
            if (!gameState.running) return;
            try {
                if (videoElement && videoElement.readyState >= 2) {
                    await hands.send({image: videoElement});
                }
            } catch (error) {
                console.warn("Hand tracking frame skipped:", error);
            }
            requestAnimationFrame(() => processVideo(videoElement));
        }

        function spawnWave() { 
            for(let i=0; i<3; i++) setTimeout(spawnTitan, i * 1000); 
        }

        function spawnTitan() {
            const scene = document.querySelector('a-scene');
            const zombie = document.createElement('a-entity');
            zombie.setAttribute('titan-ai', '');
            zombie.classList.add('zombie');

            const cam = document.querySelector('[gps-camera]').object3D;
            const angle = Math.random() * Math.PI * 2;
            const dist = CONFIG.spawnDistMin + Math.random() * (CONFIG.spawnDistMax - CONFIG.spawnDistMin);
            
            zombie.setAttribute('position', {
                x: cam.position.x + Math.sin(angle) * dist,
                y: CONFIG.yOffset,
                z: cam.position.z + Math.cos(angle) * dist
            });

            // 1. Visual Model
            const model = document.createElement('a-entity');
            model.setAttribute('gltf-model', '#titan-model');
            model.setAttribute('scale', `${CONFIG.modelScale} ${CONFIG.modelScale} ${CONFIG.modelScale}`);
            model.setAttribute('animation-mixer', 'clip: *; loop: repeat; timeScale: 1.5');
            zombie.appendChild(model);

            // 2. HITBOX
            const geometry = new THREE.BoxGeometry(30, 100, 30); 
            const material = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide }); 
            const hitboxMesh = new THREE.Mesh(geometry, material);
            hitboxMesh.position.set(0, 50, 0); 
            
            hitboxMesh.userData = { parentEntity: zombie };
            zombie.object3D.add(hitboxMesh);
            shootableObjects.push(hitboxMesh);

            scene.appendChild(zombie);
            gameState.zombies.push(zombie);
        }

        function shoot() {
            if (!gameState.running || gameState.ammo <= 0) return;
            gameState.ammo--; updateHUD();

            const gun = document.getElementById('player-gun');
            const flash = document.getElementById('muzzle-flash');
            if(gun) {
                gun.object3D.position.z += 0.3;
                flash.setAttribute('visible', 'true');
                setTimeout(() => {
                    gun.object3D.position.z -= 0.3;
                    flash.setAttribute('visible', 'false');
                }, 80);
            }

            // 1. PRIMARY: 3D RAYCASTING
            let hitFound = false;
            const raycaster = new THREE.Raycaster();
            const cameraEl = document.querySelector('[gps-camera]');
            const threeCamera = cameraEl.object3D.children.find(c => c.isCamera) || cameraEl.object3D.children[0];

            const x = (handData.x * 2) - 1;
            const y = -(handData.y * 2) + 1;

            raycaster.setFromCamera(new THREE.Vector2(x, y), threeCamera);
            const intersects = raycaster.intersectObjects(shootableObjects);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                if (hitObject.userData && hitObject.userData.parentEntity) {
                    const zombieEntity = hitObject.userData.parentEntity;
                    if (zombieEntity.dataset.dead !== "true") {
                        killZombie(zombieEntity, hitObject);
                        hitFound = true;
                    }
                }
            }

            // 2. FALLBACK: AIM ASSIST
            if (!hitFound) {
                gameState.zombies.forEach(zombie => {
                    if (hitFound || zombie.dataset.dead === "true") return;

                    const pos = new THREE.Vector3();
                    zombie.object3D.getWorldPosition(pos);
                    pos.project(threeCamera);

                    const distX = pos.x - x;
                    const distY = pos.y - y;
                    const dist = Math.sqrt(distX*distX + distY*distY);

                    if (dist < 0.25 && pos.z < 1) { 
                        killZombie(zombie, null);
                        hitFound = true;
                    }
                });
            }
        }

        function killZombie(el, hitboxMesh) {
            el.dataset.dead = "true";
            
            if (hitboxMesh) {
                const index = shootableObjects.indexOf(hitboxMesh);
                if (index > -1) shootableObjects.splice(index, 1);
            }

            el.setAttribute('animation', 'property: rotation; to: -90 0 0; dur: 1000; easing: easeOutQuad');
            
            gameState.score++;
            updateHUD();

            setTimeout(() => {
                if (el.parentNode) el.parentNode.removeChild(el);
                gameState.zombies = gameState.zombies.filter(z => z !== el);
                
                if (gameState.zombies.length < 2) {
                    gameState.wave++;
                    document.getElementById('wave').innerText = gameState.wave;
                    spawnWave();
                    gameState.ammo += 15;
                    updateHUD();
                }
            }, 1500);
        }

        function takeDamage(amt) {
            gameState.hp -= amt;
            updateHUD();
            const flash = document.getElementById('damage-flash');
            flash.style.opacity = 1; setTimeout(() => flash.style.opacity = 0, 200);
            
            if (gameState.hp <= 0) {
                gameState.running = false;
                document.getElementById('game-over-screen').style.display = 'flex';
            }
        }

        function updateHUD() {
            document.getElementById('score').innerText = gameState.score;
            document.getElementById('ammo').innerText = gameState.ammo;
            document.getElementById('hp-bar').style.width = Math.max(0, gameState.hp) + '%';
            
            if(gameState.ammo <= 0) document.getElementById('ammo').style.color = 'red';
            else document.getElementById('ammo').style.color = '#ff0000';
        }

        function updateRadar() {
            const radar = document.getElementById('radar');
            radar.innerHTML = '<div class="radar-center"></div>';
            
            const camEl = document.querySelector('[gps-camera]');
            if (!camEl || !camEl.object3D) return;

            const cam = camEl.object3D;
            const vec = new THREE.Vector3();
            cam.getWorldDirection(vec);
            const angle = Math.atan2(vec.x, vec.z);

            gameState.zombies.forEach(z => {
                if (z.dataset.dead === "true") return;
                const zPos = z.object3D.position;
                
                const dx = zPos.x - cam.position.x;
                const dz = zPos.z - cam.position.z;
                
                // Kalkulasi offset
                let rx = dx * Math.cos(angle) - dz * Math.sin(angle);
                let rz = dx * Math.sin(angle) + dz * Math.cos(angle);
                
                // Skala posisi
                let scaledRx = rx * CONFIG.radarScale;
                let scaledRz = rz * CONFIG.radarScale;

                // FIX: CLAMPING LOGIC
                // Jika zombie terlalu jauh, "tempel" titik di pinggir radar
                const distFromCenter = Math.sqrt(scaledRx**2 + scaledRz**2);
                if (distFromCenter > 42) {
                    const factor = 42 / distFromCenter;
                    scaledRx *= factor;
                    scaledRz *= factor;
                }
                
                // Konversi ke koordinat layar radar (50,50 adalah tengah)
                const px = 50 + scaledRx;
                const py = 50 - scaledRz;

                const blip = document.createElement('div');
                blip.className = 'radar-blip';
                blip.style.left = px + 'px'; 
                blip.style.top = py + 'px';
                radar.appendChild(blip);
            });
        }
    </script>
</body>
</html>
