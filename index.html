<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR Zombie Shooter: Cyberpunk Edition (WebXR 6DoF)</title>
    
    <!-- Libraries -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <!-- A-Frame Extras untuk animasi -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.0.0/dist/aframe-extras.min.js"></script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <style>
        /* RESET & BASE */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #000; 
            user-select: none; -webkit-user-select: none;
            touch-action: manipulation;
        }
        
        #input-video {
            position: absolute; top: 0; left: 0; 
            width: 320px; height: 240px; /* Kecilkan load */
            opacity: 0; /* Sembunyikan visual, tapi biarkan ada di DOM */
            z-index: -10;
            pointer-events: none;
        }

        /* UI LAYER */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 999;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Damage Overlay */
        #damage-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.8) 100%);
            opacity: 0; transition: opacity 0.1s; pointer-events: none; z-index: 2000;
            mix-blend-mode: overlay;
        }

        /* HUD PANELS */
        .hud-top { 
            display: flex; justify-content: space-between; padding: 20px; 
            padding-top: max(20px, env(safe-area-inset-top));
        }
        
        .hud-panel {
            background: rgba(0, 15, 30, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.6);
            padding: 10px 25px;
            transform: skewX(-15deg);
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .hud-content { transform: skewX(15deg); text-align: center; }

        .hud-label { 
            font-family: 'Share Tech Mono', monospace; font-size: 10px; 
            color: #00ffff; letter-spacing: 2px; text-shadow: 0 0 5px #00ffff;
        }
        
        .hud-value { 
            font-family: 'Orbitron', sans-serif; font-size: 28px; 
            color: #fff; font-weight: 900; text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .panel-kills { border-left: 5px solid #00ffff; }
        .panel-wave { border-right: 5px solid #ffaa00; }
        .panel-wave .hud-label { color: #ffaa00; text-shadow: 0 0 5px #ffaa00; }
        .panel-wave .hud-value { color: #ffaa00; }

        /* BOTTOM HUD */
        .hud-bottom {
            display: flex; align-items: flex-end; justify-content: space-between; 
            padding: 20px; padding-bottom: max(30px, env(safe-area-inset-bottom));
        }

        /* HEALTH BAR */
        .health-container { width: 200px; transform: skewX(-15deg); }
        .health-bar-bg { 
            width: 100%; height: 15px; background: rgba(50, 0, 0, 0.8); 
            border: 2px solid #ff0000; box-shadow: 0 0 10px #ff0000;
        }
        .health-bar-fill { 
            width: 100%; height: 100%; background: #ff0000; 
            box-shadow: inset 0 0 10px #500; transition: width 0.2s;
        }
        .health-label { 
            color: #fff; font-family: 'Orbitron'; font-size: 12px; 
            margin-bottom: 5px; text-shadow: 0 0 5px #ff0000; transform: skewX(15deg);
        }

        /* AMMO */
        .panel-ammo { 
            border-right: 5px solid #ff0000; background: rgba(20, 0, 0, 0.85); 
            border-color: rgba(255, 0, 0, 0.6);
        }
        .panel-ammo .hud-label { color: #ff5555; text-shadow: 0 0 5px #ff0000; }
        .panel-ammo .hud-value { color: #ff0000; font-size: 36px; }

        /* CURSOR */
        .crosshair {
            position: absolute; width: 60px; height: 60px; 
            border: 2px solid #0f0; border-radius: 50%;
            transform: translate(-50%, -50%); opacity: 0.8; 
            box-shadow: 0 0 15px #0f0, inset 0 0 10px #0f0; pointer-events: none;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
            /* Default Center untuk Head Aiming */
            left: 50%; top: 50%;
        }
        .crosshair.active { border-color: #0f0; }
        .crosshair.lost { border-color: #ffaa00; opacity: 0.5; width: 40px; height: 40px; } /* Mode Head Aim */

        .crosshair::after { content: ''; width: 4px; height: 4px; background: #fff; border-radius: 50%; }

        #status-log {
            position: absolute; top: 150px; left: 50%; transform: translateX(-50%);
            color: yellow; font-family: monospace; font-size: 12px;
            text-align: center; pointer-events: none; z-index: 1000;
            text-shadow: 1px 1px 2px black;
        }

        /* RADAR */
        .radar-box {
            position: absolute; bottom: 120px; left: 20px;
            width: 100px; height: 100px; border: 2px solid #0f0; border-radius: 50%;
            background: rgba(0, 20, 0, 0.8); overflow: hidden;
            box-shadow: 0 0 10px #0f0; pointer-events: auto;
        }
        .radar-center { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: #fff; transform: translate(-50%, -50%); border-radius: 50%; }
        .radar-blip { position: absolute; width: 8px; height: 8px; background: red; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 4px #fff; z-index: 10; }

        /* BUTTONS */
        #fire-btn {
            position: absolute; bottom: 120px; right: 30px;
            width: 100px; height: 100px; border-radius: 50%;
            background: rgba(255, 0, 0, 0.2); border: 4px solid #ff0000;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Orbitron'; color: white; font-weight: bold; font-size: 18px;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.6); pointer-events: auto; z-index: 1000;
            backdrop-filter: blur(2px);
            transition: transform 0.1s, background 0.1s;
        }
        #fire-btn:active { background: rgba(255, 0, 0, 0.8); transform: scale(0.9); }

        /* SCREENS */
        .fullscreen-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; pointer-events: auto;
        }
        .btn-start {
            background: linear-gradient(45deg, #cc0000, #990000);
            color: #fff; padding: 15px 50px; border: none;
            font-family: 'Orbitron'; font-weight: 900; font-size: 24px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            letter-spacing: 2px; cursor: pointer; margin-top: 30px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            transition: transform 0.2s;
        }
        .btn-start:hover { transform: scale(1.05); }
    </style>
</head>

<body>
    <!-- Video Element -->
    <video id="input-video" autoplay playsinline></video>

    <div id="damage-flash"></div>

    <div id="ui-layer">
        <div id="status-log">Initializing...</div>

        <div class="hud-top">
            <div class="hud-panel panel-kills">
                <div class="hud-content">
                    <div class="hud-label">KILLS</div>
                    <div class="hud-value" id="score">0</div>
                </div>
            </div>
            <div class="hud-panel panel-wave">
                <div class="hud-content">
                    <div class="hud-label">WAVE</div>
                    <div class="hud-value" id="wave">1</div>
                </div>
            </div>
        </div>

        <div class="crosshair" id="finger-cursor"></div>
        
        <div class="radar-box" id="radar"><div class="radar-center"></div></div>
        <div id="fire-btn">FIRE</div>

        <div class="hud-bottom">
            <div class="health-container">
                <div class="health-label">HP INTEGRITY</div>
                <div class="health-bar-bg"><div class="health-bar-fill" id="hp-bar"></div></div>
            </div>
            <div class="hud-panel panel-ammo">
                <div class="hud-content">
                    <div class="hud-label">AMMO</div>
                    <div class="hud-value" id="ammo">30</div>
                </div>
            </div>
        </div>
    </div>

    <div id="start-screen" class="fullscreen-overlay">
        <h1 style="font-family:'Orbitron'; color:red; font-size: 40px; text-shadow: 0 0 20px red;">ZOMBIE PROTOCOL</h1>
        <p style="color:#aaa; font-family:'Share Tech Mono'; margin-bottom: 10px;">
            [ WEBXR 6DoF ENABLED ]
        </p>
        <p style="color:#0ff; font-family:'Share Tech Mono'; font-size: 14px; max-width: 300px; line-height: 1.5;">
            1. <strong>Mundur Fisik</strong> untuk menghindar.<br>
            2. Gunakan Tangan atau <strong>Kepala</strong> untuk membidik.<br>
            3. Tap <strong>LAYAR</strong> atau Tombol untuk menembak.
        </p>
        <button class="btn-start" onclick="startGame()">ENTER AR WORLD</button>
    </div>

    <div id="game-over-screen" class="fullscreen-overlay" style="display: none;">
        <h1 style="font-family:'Orbitron'; color:red; font-size: 40px;">FATAL ERROR</h1>
        <p style="color:white; margin-bottom: 20px;">OPERATOR KILLED</p>
        <button class="btn-start" onclick="location.reload()">REBOOT SYSTEM</button>
    </div>

    <!-- WEBXR SCENE -->
    <!-- referenceSpaceType: local-floor = Koordinat 0,0,0 adalah lantai di bawah kaki user -->
    <a-scene 
        webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: #ui-layer; referenceSpaceType: local-floor;"
        renderer="antialias: true; colorManagement: true; logarithmicDepthBuffer: true;"
        loading-screen="enabled: false">

        <a-assets>
            <a-asset-item id="titan-model" src="https://raw.githack.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMan/glTF-Binary/CesiumMan.glb"></a-asset-item>
        </a-assets>

        <a-light type="ambient" color="#fff" intensity="0.8"></a-light>
        <a-light type="directional" color="#0ff" intensity="1.2" position="-1 2 0"></a-light>

        <!-- BEACON HIJAU (Titik Start) - Untuk cek world tracking -->
        <a-cylinder color="#0f0" radius="0.05" height="100" position="0 0 0" opacity="0.3"></a-cylinder>

        <a-entity id="rig" position="0 0 0">
            <a-camera id="player-camera" position="0 1.6 0" look-controls="enabled: true">
                <!-- PISTOL - POSISI DIKALIBRASI UNTUK POTRAIT -->
                <!-- x: 0.15 (Sedikit ke kanan tengah), y: -0.3 (Bawah), z: -0.5 (Depan) -->
                <a-entity id="player-gun" position="0.15 -0.3 -0.5" rotation="0 0 0" scale="1.5 1.5 1.5" visible="true">
                    <a-box color="#111" width="0.08" height="0.12" depth="0.3" position="0 0 0"></a-box>
                    <a-cylinder color="#333" radius="0.03" height="0.4" rotation="90 0 0" position="0 0.05 -0.2"></a-cylinder>
                    <a-box color="#0ff" width="0.09" height="0.02" depth="0.3" position="0 0.07 0" material="emissive: #0ff; emissiveIntensity: 2"></a-box>
                    <a-box color="#222" width="0.06" height="0.15" depth="0.08" position="0 -0.1 0.1" rotation="-20 0 0"></a-box>
                    <a-cylinder color="#0f0" radius="0.001" height="100" rotation="90 0 0" position="0 0.05 -50" opacity="0.4"></a-cylinder>
                    <a-sphere id="muzzle-flash" color="#fff" radius="0.1" position="0 0.05 -0.5" visible="false" material="emissive: #fff; emissiveIntensity: 10"></a-sphere>
                </a-entity>
            </a-camera>
        </a-entity>
        
        <!-- LANTAI INVISIBLE (Untuk Raycast) -->
        <a-plane rotation="-90 0 0" width="200" height="200" color="#000" opacity="0"></a-plane>

    </a-scene>

    <script>
        const CONFIG = {
            spawnDistMin: 6, spawnDistMax: 15,
            modelScale: 15,  // Titan Scale (15x normal)
            yOffset: 0,      // 0 = Lantai WebXR (Menapak tanah)
            damageDistance: 3.5, // Jarak Hit
            startAmmo: 50,
            lerpFactor: 0.3 
        };

        let gameState = { running: false, score: 0, wave: 1, zombies: [], hp: 100, ammo: CONFIG.startAmmo };
        let handData = { rawX: 0.5, rawY: 0.5, x: 0.5, y: 0.5, detected: false };
        let shootableObjects = []; 

        // --- CAMERA INIT ---
        async function initCamera() {
            const status = document.getElementById('status-log');
            status.innerText = "Init Camera...";
            
            const video = document.getElementById('input-video');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } }
                });
                video.srcObject = stream;
                return new Promise(resolve => {
                    video.onloadedmetadata = () => { video.play(); resolve(video); };
                });
            } catch (err) {
                console.warn("Camera access failed/refused. Falling back to Head Aim.");
                status.innerText = "Hand Tracking Disabled";
                return null;
            }
        }

        function lerp(start, end, amt) { return (1 - amt) * start + amt * end; }

        let hands;
        function setupMediaPipe() {
            document.getElementById('status-log').innerText = "Loading AI...";
            hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
            });
            hands.onResults(onHandResults);
        }

        function onHandResults(results) {
            const cursor = document.getElementById('finger-cursor');
            const status = document.getElementById('status-log');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handData.detected = true;
                status.style.display = 'none'; // Sembunyikan log jika sukses
                cursor.classList.add('active');
                cursor.classList.remove('lost');

                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8]; 
                handData.rawX = 1.0 - indexTip.x; 
                handData.rawY = indexTip.y;
            } else {
                handData.detected = false;
                cursor.classList.remove('active');
                cursor.classList.add('lost'); // Mode Head Aim (Kuning)
            }
        }

        function gameLoop() {
            if (!gameState.running) return;

            // Jika tangan terdeteksi, gunakan tangan. Jika tidak, reset ke tengah (Head Aim)
            if (handData.detected) {
                handData.x = lerp(handData.x, handData.rawX, CONFIG.lerpFactor);
                handData.y = lerp(handData.y, handData.rawY, CONFIG.lerpFactor);
            } else {
                handData.x = lerp(handData.x, 0.5, 0.1); // Balik ke tengah pelan-pelan
                handData.y = lerp(handData.y, 0.5, 0.1);
            }

            const cursor = document.getElementById('finger-cursor');
            cursor.style.left = `${handData.x * 100}%`;
            cursor.style.top = `${handData.y * 100}%`;

            const gun = document.getElementById('player-gun');
            if (gun) {
                // Kalibrasi Gerakan Pistol Potrait
                const targetX = (handData.x - 0.5) * 1.5; 
                const targetY = -(handData.y - 0.5) * 1.2; 
                
                // Gun Position Lerp (Base: 0.15, -0.3)
                gun.object3D.position.x = lerp(gun.object3D.position.x, targetX + 0.15, 0.2);
                gun.object3D.position.y = lerp(gun.object3D.position.y, targetY - 0.3, 0.2);
                
                gun.object3D.rotation.y = (-targetX * 0.8) + 0.1; // Rotasi lebih responsif
                gun.object3D.rotation.x = targetY * 0.6;
                gun.object3D.rotation.z = 0.1; 
            }
            requestAnimationFrame(gameLoop);
        }

        AFRAME.registerComponent('titan-ai', {
            init: function() { this.el.object3D.position.y = CONFIG.yOffset; },
            tick: function() {
                if (!gameState.running || this.el.dataset.dead === "true") return;
                
                const zPos = this.el.object3D.position;
                const camEl = document.getElementById('player-camera');
                if(!camEl) return;

                const camPos = new THREE.Vector3();
                camEl.object3D.getWorldPosition(camPos);
                
                const dx = zPos.x - camPos.x;
                const dz = zPos.z - camPos.z;
                const dist = Math.sqrt(dx*dx + dz*dz);

                // Chase (Hanya rotasi dan maju di XZ plane)
                if (dist > 2.0) {
                    this.el.object3D.lookAt(camPos.x, CONFIG.yOffset, camPos.z);
                    const dir = new THREE.Vector3(dx, 0, dz).normalize().negate(); 
                    this.el.object3D.position.addScaledVector(dir, 0.02); // Kecepatan sedang
                }

                if (dist <= CONFIG.damageDistance) {
                    if (!this.lastHit || Date.now() - this.lastHit > 1000) {
                        takeDamage(10);
                        this.lastHit = Date.now();
                    }
                }
            }
        });

        async function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameState.running = true;
            
            const videoEl = await initCamera();
            setupMediaPipe();
            
            if(videoEl) {
                async function processVideo() {
                    if (!gameState.running) return;
                    try { await hands.send({image: videoEl}); } catch (e) {}
                    requestAnimationFrame(processVideo);
                }
                processVideo();
            }

            gameLoop();
            spawnWave();
            setInterval(updateRadar, 150);

            // FIX: GLOBAL SHOOT LISTENER (Tap Anywhere)
            // Ini mengatasi masalah tombol "fire" yang tidak responsif di AR
            const scene = document.querySelector('a-scene');
            
            // 1. WebXR Select Event (Controller/Screen Tap)
            scene.addEventListener('select', () => shoot());
            
            // 2. Window Click/Touch (Fallback)
            window.addEventListener('click', (e) => {
                // Cegah double fire jika klik tombol start
                if(e.target.classList.contains('btn-start')) return;
                shoot();
            });
            
            // 3. Tombol Fire UI (Visual)
            const fireBtn = document.getElementById('fire-btn');
            fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); shoot(); }, {passive:false});
        }

        function spawnWave() { for(let i=0; i<3; i++) setTimeout(spawnTitan, i * 1000); }

        function spawnTitan() {
            const scene = document.querySelector('a-scene');
            const zombie = document.createElement('a-entity');
            zombie.setAttribute('titan-ai', '');
            zombie.classList.add('zombie');

            const angle = Math.random() * Math.PI * 2;
            const dist = CONFIG.spawnDistMin + Math.random() * (CONFIG.spawnDistMax - CONFIG.spawnDistMin);
            
            // Spawn di lantai (y=0)
            zombie.setAttribute('position', {
                x: Math.sin(angle) * dist,
                y: CONFIG.yOffset, 
                z: Math.cos(angle) * dist
            });

            const model = document.createElement('a-entity');
            model.setAttribute('gltf-model', '#titan-model');
            model.setAttribute('scale', `${CONFIG.modelScale} ${CONFIG.modelScale} ${CONFIG.modelScale}`);
            model.setAttribute('animation-mixer', 'clip: *; loop: repeat; timeScale: 1.5');
            zombie.appendChild(model);

            // Hitbox Besar
            const geometry = new THREE.BoxGeometry(0.8 * CONFIG.modelScale, 2 * CONFIG.modelScale, 0.8 * CONFIG.modelScale);
            const material = new THREE.MeshBasicMaterial({ visible: false }); 
            const hitboxMesh = new THREE.Mesh(geometry, material);
            hitboxMesh.position.set(0, 1 * CONFIG.modelScale, 0);
            
            hitboxMesh.userData = { parentEntity: zombie };
            zombie.object3D.add(hitboxMesh);
            shootableObjects.push(hitboxMesh);

            scene.appendChild(zombie);
            gameState.zombies.push(zombie);
        }

        function shoot() {
            if (!gameState.running || gameState.ammo <= 0) return;
            gameState.ammo--; updateHUD();

            const gun = document.getElementById('player-gun');
            const flash = document.getElementById('muzzle-flash');
            if(gun) {
                gun.object3D.position.z += 0.2;
                flash.setAttribute('visible', 'true');
                setTimeout(() => {
                    gun.object3D.position.z -= 0.2;
                    flash.setAttribute('visible', 'false');
                }, 80);
            }

            let hitFound = false;
            const raycaster = new THREE.Raycaster();
            const camEl = document.getElementById('player-camera');
            const threeCamera = camEl.getObject3D('camera');

            const x = (handData.x * 2) - 1;
            const y = -(handData.y * 2) + 1;

            raycaster.setFromCamera(new THREE.Vector2(x, y), threeCamera);
            const intersects = raycaster.intersectObjects(shootableObjects);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                if (hitObject.userData?.parentEntity?.dataset.dead !== "true") {
                    killZombie(hitObject.userData.parentEntity, hitObject);
                    hitFound = true;
                }
            }

            // Fallback: Aim Assist (Screen Space)
            if (!hitFound) {
                gameState.zombies.forEach(zombie => {
                    if (hitFound || zombie.dataset.dead === "true") return;
                    const pos = new THREE.Vector3();
                    zombie.object3D.getWorldPosition(pos);
                    pos.project(threeCamera);
                    const dist = Math.sqrt((pos.x - x)**2 + (pos.y - y)**2);
                    
                    // Tolerance 0.2 (Cukup besar untuk head aim)
                    if (dist < 0.2 && pos.z < 1) {
                        killZombie(zombie, null);
                        hitFound = true;
                    }
                });
            }
        }

        function killZombie(el, hitboxMesh) {
            el.dataset.dead = "true";
            if (hitboxMesh) {
                const index = shootableObjects.indexOf(hitboxMesh);
                if (index > -1) shootableObjects.splice(index, 1);
            }
            el.setAttribute('animation', 'property: rotation; to: -90 0 0; dur: 800; easing: easeOutQuad');
            gameState.score++;
            updateHUD();
            setTimeout(() => {
                if (el.parentNode) el.parentNode.removeChild(el);
                gameState.zombies = gameState.zombies.filter(z => z !== el);
                if (gameState.zombies.length < 2) spawnWave();
            }, 1000);
        }

        function takeDamage(amt) {
            gameState.hp -= amt;
            updateHUD();
            const flash = document.getElementById('damage-flash');
            flash.style.opacity = 1; 
            setTimeout(() => flash.style.opacity = 0, 200);
            
            if (gameState.hp <= 0) {
                gameState.running = false;
                document.getElementById('game-over-screen').style.display = 'flex';
            }
        }

        function updateHUD() {
            document.getElementById('score').innerText = gameState.score;
            document.getElementById('ammo').innerText = gameState.ammo;
            document.getElementById('hp-bar').style.width = Math.max(0, gameState.hp) + '%';
        }

        function updateRadar() {
            const radar = document.getElementById('radar');
            radar.innerHTML = '<div class="radar-center"></div>';
            
            const camEl = document.getElementById('player-camera');
            if (!camEl) return;

            const camPos = new THREE.Vector3();
            camEl.object3D.getWorldPosition(camPos);
            
            const vec = new THREE.Vector3();
            camEl.object3D.getWorldDirection(vec);
            const angle = Math.atan2(vec.x, vec.z);

            gameState.zombies.forEach(z => {
                if (z.dataset.dead === "true") return;
                const zPos = z.object3D.position;
                
                const dx = zPos.x - camPos.x;
                const dz = zPos.z - camPos.z;
                
                const rx = dx * Math.cos(angle) - dz * Math.sin(angle);
                const rz = dx * Math.sin(angle) + dz * Math.cos(angle);
                
                const px = 50 + (rx * CONFIG.radarScale * 2.0); 
                const py = 50 - (rz * CONFIG.radarScale * 2.0);
                
                if (Math.sqrt((px-50)**2 + (py-50)**2) < 45) {
                    const blip = document.createElement('div');
                    blip.className = 'radar-blip';
                    blip.style.left = px + 'px'; 
                    blip.style.top = py + 'px';
                    radar.appendChild(blip);
                }
            });
        }
    </script>
</body>
</html>
